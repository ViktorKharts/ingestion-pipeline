// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package pipeline

import (
	"context"
)

const createDocument = `-- name: CreateDocument :one
INSERT INTO documents (
  drive_file_id, filename, filepath, content, extension, last_modified, size_bytes
) VALUES (
  ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, drive_file_id, filename, filepath, content, extension, last_modified, size_bytes
`

type CreateDocumentParams struct {
	DriveFileID  string
	Filename     string
	Filepath     string
	Content      string
	Extension    string
	LastModified string
	SizeBytes    int64
}

func (q *Queries) CreateDocument(ctx context.Context, arg CreateDocumentParams) (Document, error) {
	row := q.db.QueryRowContext(ctx, createDocument,
		arg.DriveFileID,
		arg.Filename,
		arg.Filepath,
		arg.Content,
		arg.Extension,
		arg.LastModified,
		arg.SizeBytes,
	)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.DriveFileID,
		&i.Filename,
		&i.Filepath,
		&i.Content,
		&i.Extension,
		&i.LastModified,
		&i.SizeBytes,
	)
	return i, err
}

const getDocument = `-- name: GetDocument :one
SELECT id, drive_file_id, filename, filepath, content, extension, last_modified, size_bytes FROM documents
WHERE id = ? LIMIT 1
`

func (q *Queries) GetDocument(ctx context.Context, id int64) (Document, error) {
	row := q.db.QueryRowContext(ctx, getDocument, id)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.DriveFileID,
		&i.Filename,
		&i.Filepath,
		&i.Content,
		&i.Extension,
		&i.LastModified,
		&i.SizeBytes,
	)
	return i, err
}

const listDocuments = `-- name: ListDocuments :many
SELECT id, drive_file_id, filename, filepath, content, extension, last_modified, size_bytes FROM documents
ORDER BY filename
`

func (q *Queries) ListDocuments(ctx context.Context) ([]Document, error) {
	rows, err := q.db.QueryContext(ctx, listDocuments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Document
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.DriveFileID,
			&i.Filename,
			&i.Filepath,
			&i.Content,
			&i.Extension,
			&i.LastModified,
			&i.SizeBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDocuments = `-- name: SearchDocuments :many
SELECT id, drive_file_id, filename, filepath, content, extension, last_modified, size_bytes
FROM documents
WHERE id IN (
    SELECT rowid FROM documents_fts WHERE documents_fts.content MATCH ?1
)
LIMIT ?2
`

type SearchDocumentsParams struct {
	Query string
	Limit int64
}

func (q *Queries) SearchDocuments(ctx context.Context, arg SearchDocumentsParams) ([]Document, error) {
	rows, err := q.db.QueryContext(ctx, searchDocuments, arg.Query, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Document
	for rows.Next() {
		var i Document
		if err := rows.Scan(
			&i.ID,
			&i.DriveFileID,
			&i.Filename,
			&i.Filepath,
			&i.Content,
			&i.Extension,
			&i.LastModified,
			&i.SizeBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
